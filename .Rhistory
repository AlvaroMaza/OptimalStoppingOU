z = sin(seq(0, 2*pi, length.out = 100)) * critical_radius,
type = 'scatter3d',
mode = 'lines',
line = list(color = 'lightblue', width = 2),
showlegend = FALSE
) %>%
add_trace(
x = rep(0, 100),
y = cos(seq(0, 2*pi, length.out = 100)) * critical_radius,
z = sin(seq(0, 2*pi, length.out = 100)) * critical_radius,
type = 'scatter3d',
mode = 'lines',
line = list(color = 'lightblue', width = 2),
showlegend = FALSE
)
# Show the plot
fig
# Function to generate sphere coordinates
generate_sphere <- function(radius, n = 100) {
theta <- seq(0, 2 * pi, length.out = n)
phi <- seq(0, pi, length.out = n)
theta_grid <- rep(theta, each = length(phi))
phi_grid <- rep(phi, length(theta))
x <- radius * sin(phi_grid) * cos(theta_grid)
y <- radius * sin(phi_grid) * sin(theta_grid)
z <- radius * cos(phi_grid)
return(list(x = x, y = y, z = z))
}
# Generate sphere coordinates
sphere_coords <- generate_sphere(critical_radius)
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 5)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 3, opacity = 0.5),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')),
title = "3D Plot of Vectors with Acceptance Region")
# Show the plot
fig
check_convergence <- function(mu, sigma2, alpha, T = 4, delta = 0.01, M = 1000, alpha_level = 0.05) {
n <- T / delta
theta <- c(alpha, mu, sigma2)
K <- length(theta)
chi_squared_stats <- numeric(M)
vectors <- matrix(NA, nrow = M, ncol = K)
for (i in 1:M) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
R <- chol(fisher_info)
z <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
chi_squared_stats[i] <- sum(z^2)
vectors[i, ] <- z
}
chi_squared_critical_value <- qchisq(1 - alpha_level, df = K)
coverage_probability <- mean(chi_squared_stats <= chi_squared_critical_value)
return(list(vectors = vectors, chi_squared_stats = chi_squared_stats,
critical_value = chi_squared_critical_value,
coverage_probability = coverage_probability))
}
# Parameters
mu <- 20
sigma2 <- 1
alpha <- 3
M <- 1000
alpha_level <- 0.1
library(plotly)
# Check convergence for n=1000
convergence_results <- check_convergence(mu, sigma2, alpha, M = M, alpha_level = alpha_level)
coverage_probability <- convergence_results$coverage_probability
vectors <- convergence_results$vectors
critical_value <- convergence_results$critical_value
chi_squared_stats <- convergence_results$chi_squared_stats
# Calculate the critical radius
critical_radius <- sqrt(critical_value)
# Function to generate sphere coordinates
generate_sphere <- function(radius, n = 100) {
theta <- seq(0, 2 * pi, length.out = n)
phi <- seq(0, pi, length.out = n)
theta_grid <- rep(theta, each = length(phi))
phi_grid <- rep(phi, length(theta))
x <- radius * sin(phi_grid) * cos(theta_grid)
y <- radius * sin(phi_grid) * sin(theta_grid)
z <- radius * cos(phi_grid)
return(list(x = x, y = y, z = z))
}
# Generate sphere coordinates
sphere_coords <- generate_sphere(critical_radius)
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 5)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 3, opacity = 0.5),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')),
title = "3D Plot of Vectors with Acceptance Region")
# Show the plot
fig
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 5)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')),
title = "3D Plot of Vectors with Acceptance Region")
# Show the plot
fig
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 3)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')),
title = "3D Plot of Vectors with Acceptance Region")
# Show the plot
fig
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 3)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')))
# Show the plot
fig
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 3)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')),
title = "3D Plot of Vectors with Acceptance Region")
# Show the plot
fig
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 3)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')))
# Show the plot
fig
pairwise_plot <- function(mu, sigma2, alpha, T = 4, delta = 0.01) {
n <- T/delta
theta <- c(alpha, mu, sigma2)
# Generate data for sample_size = 100
data_100 <- data.frame(alpha = numeric(length = 100),
mu = numeric(length = 100),
sigma2 = numeric(length = 100))
for (i in 1:100) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_100[i,] <- point
}
# Generate data for sample_size = 1000
data_1000 <- data.frame(alpha = numeric(length = 1000),
mu = numeric(length = 1000),
sigma2 = numeric(length = 1000))
for (i in 1:1000) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_1000[i,] <- point
}
# Combine data
data_100$sample_size <- "100"
data_1000$sample_size <- "1000"
combined_data <- rbind(data_100, data_1000)
# Compute correlations
cor_100 <- cor(data_100[,1:3])
cor_1000 <- cor(data_1000[,1:3])
#print(cor_100)
# Plot functions
density_with_normal <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_density(aes(color = sample_size), alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
theme_minimal() +
xlim(c(-6, 6))
}
scatterplots <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(aes(color = sample_size), alpha = 0.7) +
theme_minimal() +
xlim(c(-6, 6)) +
ylim(c(-6, 6))
}
upper_corr <- function(data, mapping, ...) {
x_var <- as.character(mapping$x[2])
y_var <- as.character(mapping$y[2])
corr_100 <- round(cor_100[x_var, y_var], 4)
corr_1000 <- round(cor_1000[x_var, y_var], 4)
ggplot() +
annotate("text", x = 0.5, y = c(0.55, 0.5, 0.49, 0.45),
label = c("", paste(corr_100), paste(corr_1000), ""),
color = c("white", "red", "turquoise", "white"), size = 5, hjust = 0.5) +
theme_minimal()
}
ggpairs(combined_data, columns = 1:3,
upper = list(continuous = wrap(upper_corr)),
lower = list(continuous = scatterplots),
diag = list(continuous = density_with_normal)
)
}
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 2, alpha = 3)
library(ggplot2)
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 2, alpha = 3)
print(plot_combined)
?ggpairs
library(GGally)
library(gridExtra)
library(grid)
print(plot_combined)
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 2, alpha = 3)
print(plot_combined)
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 1, alpha = 3)
print(plot_combined)
pairwise_plot <- function(mu, sigma2, alpha, T = 4, delta = 0.01) {
n <- T/delta
theta <- c(alpha, mu, sigma2)
# Generate data for sample_size = 100
data_100 <- data.frame(alpha = numeric(length = 100),
mu = numeric(length = 100),
sigma2 = numeric(length = 100))
for (i in 1:100) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_100[i,] <- point
}
# Generate data for sample_size = 1000
data_1000 <- data.frame(alpha = numeric(length = 1000),
mu = numeric(length = 1000),
sigma2 = numeric(length = 1000))
for (i in 1:1000) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_1000[i,] <- point
}
# Combine data
data_100$sample_size <- "100"
data_1000$sample_size <- "1000"
combined_data <- rbind(data_100, data_1000)
# Compute correlations
cor_100 <- cor(data_100[,1:3])
cor_1000 <- cor(data_1000[,1:3])
#print(cor_100)
# Plot functions
density_with_normal <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_density(aes(color = sample_size), alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
theme_minimal() +
xlim(c(-6, 6))
}
scatterplots <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(aes(color = sample_size), alpha = 0.2) +
theme_minimal() +
xlim(c(-6, 6)) +
ylim(c(-6, 6))
}
upper_corr <- function(data, mapping, ...) {
x_var <- as.character(mapping$x[2])
y_var <- as.character(mapping$y[2])
corr_100 <- round(cor_100[x_var, y_var], 4)
corr_1000 <- round(cor_1000[x_var, y_var], 4)
ggplot() +
annotate("text", x = 0.5, y = c(0.55, 0.5, 0.49, 0.45),
label = c("", paste(corr_100), paste(corr_1000), ""),
color = c("white", "red", "turquoise", "white"), size = 5, hjust = 0.5) +
theme_minimal()
}
ggpairs(combined_data, columns = 1:3,
upper = list(continuous = wrap(upper_corr)),
lower = list(continuous = scatterplots),
diag = list(continuous = density_with_normal)
)
}
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 1, alpha = 3)
print(plot_combined)
pairwise_plot <- function(mu, sigma2, alpha, T = 1, delta = 0.01) {
n <- T/delta
theta <- c(alpha, mu, sigma2)
# Generate data for sample_size = 100
data_100 <- data.frame(alpha = numeric(length = 100),
mu = numeric(length = 100),
sigma2 = numeric(length = 100))
for (i in 1:100) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_100[i,] <- point
}
# Generate data for sample_size = 1000
data_1000 <- data.frame(alpha = numeric(length = 1000),
mu = numeric(length = 1000),
sigma2 = numeric(length = 1000))
for (i in 1:1000) {
X <- r_ou(n = 1, t = seq(0, T, len = n), x0 = 28, mu = mu, sigma = sqrt(sigma2), alpha = alpha)$data
result <- est_OU(X, delta)
fisher_info <- fisher_info_second_derivatives(result$alpha, result$mu, result$sigma2, X, delta,
d2_logL_dalpha2, d2_logL_dmu2, d2_logL_dsigma2,
d2_logL_dalphadmu, d2_logL_dalphadsigma, d2_logL_dmudsigma)
# fisher_info_gradient <- fisher_info_gradient(result$alpha, result$mu, result$sigma2, X, delta,
#                                              d_logL_dalpha, d_logL_dmu, d_logL_dsigma2)
R <- chol(fisher_info)
point <- sqrt(n) * (R %*% (c(result$alpha, result$mu, result$sigma2) - theta))
data_1000[i,] <- point
}
# Combine data
data_100$sample_size <- "100"
data_1000$sample_size <- "1000"
combined_data <- rbind(data_100, data_1000)
# Compute correlations
cor_100 <- cor(data_100[,1:3])
cor_1000 <- cor(data_1000[,1:3])
#print(cor_100)
# Plot functions
density_with_normal <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_density(aes(color = sample_size), alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
theme_minimal() +
xlim(c(-6, 6))
}
scatterplots <- function(data, mapping, ...) {
ggplot(data = data, mapping = mapping) +
geom_point(aes(color = sample_size), alpha = 0.7) +
theme_minimal() +
xlim(c(-6, 6)) +
ylim(c(-6, 6))
}
upper_corr <- function(data, mapping, ...) {
x_var <- as.character(mapping$x[2])
y_var <- as.character(mapping$y[2])
corr_100 <- round(cor_100[x_var, y_var], 4)
corr_1000 <- round(cor_1000[x_var, y_var], 4)
ggplot() +
annotate("text", x = 0.5, y = c(0.55, 0.5, 0.49, 0.45),
label = c("", paste(corr_100), paste(corr_1000), ""),
color = c("white", "red", "turquoise", "white"), size = 5, hjust = 0.5) +
theme_minimal()
}
ggpairs(combined_data, columns = 1:3,
upper = list(continuous = wrap(upper_corr)),
lower = list(continuous = scatterplots),
diag = list(continuous = density_with_normal)
)
}
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 1, alpha = 3)
print(plot_combined)
# Generate and save the combined plot
#pdf("plots/3_pairwise_plot.pdf", width = 12, height = 12)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 1, alpha = 3)
print(plot_combined)
plot_combined <- pairwise_plot(mu = 20, sigma2 = 1, alpha = 3)
print(plot_combined)
# Parameters
mu <- 20
sigma2 <- 2
alpha <- 3
M <- 1000
alpha_level <- 0.1
# Check convergence for n=1000
convergence_results <- check_convergence(mu, sigma2, alpha, M = M, alpha_level = alpha_level)
coverage_probability <- convergence_results$coverage_probability
vectors <- convergence_results$vectors
critical_value <- convergence_results$critical_value
chi_squared_stats <- convergence_results$chi_squared_stats
# Calculate the critical radius
critical_radius <- sqrt(critical_value)
# Function to generate sphere coordinates
generate_sphere <- function(radius, n = 100) {
theta <- seq(0, 2 * pi, length.out = n)
phi <- seq(0, pi, length.out = n)
theta_grid <- rep(theta, each = length(phi))
phi_grid <- rep(phi, length(theta))
x <- radius * sin(phi_grid) * cos(theta_grid)
y <- radius * sin(phi_grid) * sin(theta_grid)
z <- radius * cos(phi_grid)
return(list(x = x, y = y, z = z))
}
# Generate sphere coordinates
sphere_coords <- generate_sphere(critical_radius)
# Create a 3D scatter plot with Plotly
fig <- plot_ly(x = vectors[,1], y = vectors[,2], z = vectors[,3],
type = 'scatter3d', mode = 'markers',
marker = list(color = ifelse(chi_squared_stats > critical_value, 'red', 'blue'),
size = 3)) %>%
add_trace(x = sphere_coords$x, y = sphere_coords$y, z = sphere_coords$z,
type = 'scatter3d', mode = 'markers',
marker = list(color = 'lightblue', size = 2, opacity = 0.3),
showlegend = FALSE) %>%
layout(scene = list(xaxis = list(title = 'Z1'),
yaxis = list(title = 'Z2'),
zaxis = list(title = 'Z3')))
# Show the plot
fig
# Calculate the critical value for the given confidence level
z_alpha <- qnorm(1 - alpha_level / 2)
# Calculate the standard error
standard_error <- sqrt(coverage_probability * (1 - coverage_probability) / M)
# Compute the confidence interval
lower_bound <- (1-alpha_level) - z_alpha * standard_error
upper_bound <- (1-alpha_level) + z_alpha * standard_error
cat("Observed coverage probability:", coverage_probability, "\n")
cat("90% Confidence interval:", lower_bound, "-", upper_bound, "\n")
library(rgl)
install.packages("knitr")
library(rgl)
update.packages()
library(rgl)
install.packages(rgl)
install.packages("rgl")
library(rgl)
install.packages("htmlwidgets")
install.packages("htmlwidgets")
library(rgl)
install.packages("htmlwidgets")
install.packages("htmlwidgets")
install.packages("htmlwidgets")
library(rgl)
library(htmlwidgets)
